#2부: 소프트웨어

##로그 18: 알고리즘과 초콜릿 케이크 레시피

정리:  
알고리즘은 세심하고 정확하고 명료하게 작성된 납세신고서의 컴퓨터과학 버전이라고 할 수 있다. 어떤 결과를 정확하게 계산하도록 보장된 일련의 단계다.
각 단계는 기본 연산으로 표현되어 있으며 연산의 의미는 완전히 명시된다. 알고리즘은 지능이나 상상력이 없는 개체가 수행하더라도 연산의 의미와 수행 방법에 의심의 여지가 없을 정도로 상세하고 정확하게 일련의 연산을 명시해야 한다.

##로그 19: 반에서 가장 키 큰 사람 찾기: 선형 알고리즘

정리:  
만약 반에서 가장 키 큰 사람을 찾는 알고리즘을 만들려면 이렇게 한다. 학생들의 키를 물어가며 그 순간에 가장 키가 큰 사람만 기억하는 것이다.
그럼 최종적으로 가장 키 큰 사람 한 명의 이름을 갖고 있게 된다. 하지만 키가 같은 학생들의 무리 중에 가장 사람 수가 많은 무리를 찾는 건 더 어렵다.
키가 같은 학생들을 다 기억하고 있어야 하기 때문이다. 그래서 자료 구조가 필요하게 된다. 자료 구조는 계산 과정에서 필요한 정보를 표현하는 방법이다.
알고리즘의 효율성도 중요하다. 계산 시간이 데이터의 양에 어떻게 비례하느냐에 따라 효율이 정해진다.

##로그 20: 10억 개 전화번호에서 이름 찾기: 이진 검색

정리:  
종이로 된 옛날 전화번호부에서 이름을 찾으려면 보통 중간부터 본다. 알파벳 순으로 정렬되어 있기 때문에 한쪽을 펼치면 다음엔 앞부분을 볼지 뒷부분을 볼지 결정된다.
이렇게 선택지가 반씩 줄어드는 알고리즘을 이진 검색이라고 한다. 이진 검색은 분할 정복이라는 일반적인 전략의 한 가지 예다.

##로그 21: 검색을 쉽게 만드는 정렬: 선택 정렬 vs 퀵 정렬

정리:
애초에 이름을 알파벳순으로 정렬을 하려면? 이진 검색 전에 무언가가 일어나야 한다. 수많은 정렬 방법 중 하나는 선택 정렬이다. 모든 원소를 돌아보며 가장 맨 앞의 원소를 발견할 때까지 진행한다. 가장 맨 앞의 원소를 발견하는 방법은 각 원소를 확인하며 맨 앞에 있는 원소보다 더 앞 순의 원소인 경우 그 원소를 맨 앞으로 둔다. 모든 원소를 한 번씩 확인한 후에 맨 앞에 온 원소가 제일 첫 번째 순으로 오는 원소일 것이다. 그렇게 되면 그 첫 원소를 확정 짓고 나머지 원소로 위를 반복한다. 속도는 n^2이다. 선택 정렬보다 더 빠른 방법으로 퀵 정렬이 있다. 퀵 정렬은 분할 정복의 좋은 예시다. 바로 기준을 정해 그룹을 반으로 쪼개고 그 안에서 정렬하고 쪼개는 것을 더 이상 반복할 수 없을 때까지 진행한다. 퀵정렬의 속도는 n log n 이다. 같은 크기의 그룹으로 나눠야만 효율적이다.

##로그 22: 10개 도시를 최단거리로 여행하는 법

정리:
2^n의 복잡도는 효율이 엄청 낮다. 지수 알고리즘은 사실상 모든 가능한 경우를 하나씩 시도해 봐야만 하는 상황에서 발생한다. 암호 기법에 사용되는 알고리즘은 특정 계산 과제를 수행하는 일이 지수 복잡도를 갖도록 하는 데 기반을 둔다. 쉬운 문제는 복잡도 면에서 '다항'이다. n^2, n^3 등등을 말한다. 실제로 발생하는 많은 문제는 지수 알고리즘이 필요하다. 즉 다항 알고리즘으로 풀 수 없다. 이를 NP 문제라고 한다. NP 문제는 해결책을 빨리 찾을 수는 없지만, 해결책을 알고 있다면 그것이 맞는지는 빨리 입증할 수 있다. NP는 비결정적 다항을 의미한다. 이 말은 결정을 내려야 할 때 항상 옳게 추측하는 알고리즘이 있다면 NP문제가 그 알고리즘에 의해 다항 시간 내에 해결될 수 있다는 뜻이다 (이론적이다). NP 문제의 예시로 여행하는 외판원 문제가 있다. 이 문제에서 외판원은 자신이 사는 도시에서 출발해 어떤 순서로든 다른 도시를 모두 방문하고 나서 다시 출발점으로 돌아와야 한다. 여기서 목표는 각 도시를 정확히 한 번씩 방문하고 전체 여행한 거리를 최소로 만드는 것이다.
이 문제는 통학 버스나 쓰레기차가 다니는 경로를 효율적으로 만드는 일과 아이디어가 같다. 직관적으로 볼 수 있는 해법은 최근접 이웃 휴리스틱으로 찾은 해법이 있다. 한 도시에서 시작해 매번 아직 방문하지 않은 도시 중 가장 가까운 도시로 이동하는 방식이다. 스티븐 쿡이 1971년에 수학적 연구 결과를 발표했다. 이런 문제 중 다수가 서로 동등하다는 것을 증명했다. 그러니까 만약 우리가 어떤 문제를 해결하는 다항 시간 알고리즘을 찾을 수 있다면, 이와 유사한 모든 문제에 대한 다항 시간 알고리즘을 찾아낼 수 있다는 뜻이다. 복잡도를 다룰 때 생각해야 할 것은, 복잡도란 대부분 최악의 경우에 대한 것이라는 거다. 보통은 최악의 경우까지 가지 않는다. 즉, 어떤 문제는 답을 계산하는 데 많은 시간이 필요하겠지만 모든 문제를 그렇게 난해하게 접근할 필요가 없다. 현실에서는 N이 그렇게 크지 않다. 따라서 실행속도가 충분히 빠를 수 있다. 실행속도가 좀 걸리더라도 실제 상황에서는 근사치만 구하는 것으로도 충분하다.

##로그 23: 요약

정리:
컴퓨터과학 분야에서는 '얼마나 빨리 계산할 수 있는가'에 관한 개념을 정리해 왔다. 알고리즘의 복잡도가 그런 것이다. 데이터의 양과 관련해서 실행 시간을 표현하는 것일 분이지 어떤 컴퓨터가 다른 컴퓨터보다 빠른지, 누가 더 효율적인 알고리즘을 구사하는지는 핵심이 아니다. 따라서 어떤 문제의 본질적인 복잡도와 알고리즘의 복잡도도 일치할 필요는 없다. 오히려 알고리즘과 복잡도는 연구의 영역이고 어떤 문제가 계산 가능하고 어떤 문제가 불가능한지, 어떻게 하면 빨리 계산하고 메모리의 효율을 높일 수 있는지, 혹은 그 사이의 균형을 어떻게 유지하면서 계산할 수 있는지에 관심을 둔다. 알고리즘은 네트워크, 암호, 음성 이해, 영상 인식 등 다양한 분야의 핵심이 된다. 이런 서비스는 모두 대량의 데이터 처리를 요구하기 때문에 사용되는 알고리즘은 선형 이상의 성능을 지니고 있는 것이 좋다. 또 분산된 처리를 할 수 있게 병렬화가 가능해야 한다.

##로그 24: 알고리즘은 이상, 프로그래밍은 현실

정리:  
알고리즘은 어떤 추상적이고 이상적인 절차를 의미한다. 반면 프로그램은 실제 컴퓨터가 수행해야 하는 모든 단계를 의미한다. 따라서 한쪽은 이상적이고 한쪽은 실재한다. 여기서 실제와 이상의 차이는 메모리 제한, 잘못 입력된 데이터, 하드웨어 결함, 네트워크 연결 불량, 그리고 사람이기에 할 수 밖에 없는 실수 등이 있다.

##로그 25: 다른 프로그램을 처리하기 위한 프로그램

정리:
특정한 처리를 하는 프로그램을 **어셈블러**라고 한다. 원래는 다른 프로그래머가 사전에 작성했던 프로그램에서 필요한 부분을 모으는 역할을 하기도 했기에 붙은 이름이다. 어셈블러는 프로그램을 수정하는 일을 훨씬 쉽게 해준다. 프로그래머가 명령어를 추가하거나 삭제할 때 변경 기록을 직접 관리하는 대신 어셈블러가 각 명령어와 데이터 값이 메모리상 어느 위치에 있을지 파악해 주기 때문이다. 어셈블리 언어는 보통 프로세서의 명령어와 일대일로 연결된다. 즉 특정 프로세서용 어셈블리 언어를 다른 프로세서용으로 변환하고 싶다면 프로그램을 완전히 새로 작성해야 한다.

##로그 26: 고수준 언어에서 프로그램 실행까지

정리:
우리가 이해하는 언어와 컴퓨터가 이해하는 언어 사이의 거리가 멀기 때문에 단계적으로 번역을 한다. 이때 우리가 사용하는 언어랑 가장 가까우면서 컴퓨터 프로그래밍을 할 때 사용하는 언어를 고수준 프로그래밍 언어라고 한다. 이 언어는 번역기 프로그램, 혹은 컴파일러를 통해 어셈블리 언어로 된 명령어로 변환된 다음 최종적으로 비트로 변환되어 메모리에 로드되고 실행된다. 고수준 언어는 사람들이 생각하는 방식에 더 가깝기 때문에 배우고 사용하기 쉽다. 그리고 특정 아키텍처에 종속되지 않는다는 장점이 있다. 또 컴파일 단계에서 철자 오류, 구문 오류 등 명백한 에러를 미리 점검하게 해준다. 초기 고수준 언어들로는 포트란, 코볼, 베이직 등이 있다.

##로그 27: 작문과 비슷한 프로그래밍

정리:
프로그래밍은 작문과 비슷하다. 작문에는 문체와 어휘가 중요하듯이 프로그래밍도 같은 동작을 하는 프로그램이라도 프로그래밍 문법을 어떻게 구사했는지에 따라 프로그래머의 역량을 파악할 수 있다. 세상에는 프로그래밍 언어가 많은데, 각 언어는 효율, 표현력, 안전성, 복잡성 같은 특성을 특화된 분야에 맞춰 조절하며 사용되고 있기 때문이다.

##로그 28: 구글 같은 서비스는 어떻게 개발할까?

정리:
큰 서비스를 개발힐 때 사용하는 전략은 단계적으로 나뉜다. 먼저 무엇을 해야 하는지 파악한다. 그 다음에는 큰 그림부터 시작해서 작은 부분까지 나누고 각 부분을 작업하면서 큰 그림으로서 일관성을 보이는지 틈틈이 확인해야 한다. 어려운 부분은 바로 각각의 프로그래머들이 작업한 것들을 통일하는 것이다. 보통 대학에서 만드는 간단한 웹 서비스나 웹 애플리케이션은 2000~3000줄의 코드로 구성되어 있는데 대규모 시스템은 수 백만에서 수 천만 행의 코드로 구성되어 있을 것이다. 2015년 구글의 전체 코드 규모는 약 20억 행이었다고 한다. 이렇게 큰 규모의 소프트웨어를 개발하기 위해서는 프로그래밍 담당, 테스트 담당, 문서 작성 담당 등으로 이루어진 팀이 여럿 필요할 것이다. 각 팀은 서비스 관리를 위해 서로 계속해서 소통을 해야만 한다. 워낙 많은 사람들이 모여서 작업을 하다보니 버그와 같은 문제점은 항상 발생하기 마련이다. 버그 이외에도 보안 취약점 같은 문제, 그리고 하드웨어의 변화, 소프트웨어의 변화, 담당자의 변화로 인해 생기는 모든 문제점들은 언제나 생기기 때문에 이를 고려하며 유지보수에 힘써야 한다.

##로그 29: 구글과 오라클의 저작권 소송

정리:
1999년 9월에 아마존이 "원클릭"이라는 소프트웨어 특허를 냈다. 말 그대로 마우스 클릭 한 번으로 주문을 하는 방법에 대한 특허였다. 특허를 낼 만한 사항이 아니라는 의견이 많아 논란이 있었지만 결국 항소를 통해 특허가 인정이 되었으며 20년동안 특허에 대한 라이선스를 받았다. 소프트웨어 특허를 받는 일이 쉬워지면서 특허 관리 전문 사업이 증가하기 시작했다. 해당 사업을 하는 기업들은 그 발명을 사용하는 것이 아니라 허가 없이 특허를 침해 중인 기업을 소송하기 위한 것이 목적이다. 이러한 특허 말고도 어떤 소프트웨어를 사용하려면 라이선스에 동의해야 한다. 그 조항을 확인해보면 소프트웨어는 판매된 것이 아니라 사용권이 부여되었다고 말한다. 법적으로 허용된 저작권의 경계가 모호하다. 2010년 오라클이 자바 언어를 만든 썬 마이크로시스템즈를 인수했는데, 구글이 자바 API를 무단으로 사용하고 있다고 소송을 걸었다. API가 저작권 취득 대상이 될 수 있지만 구글에서 자바 API를 사용한 것은 공정하게 사용한 것으로 인정되었다.

##로그 30: 기술 표준의 중요성

정리:
표준은 어떤 틀이 정해진 규격이다. 표준을 지키면 우리가 편하다. 전원 플러그 크기와 모양이 표준을 지키는 것이 그 예다(물론 나라마다는 다를 수 있다). 이 표준을 위해 경쟁을 하는 경우도 있다. HD DVD와 블루레이 간의 경쟁이 그 예다. 소프트웨어도 아스키코드, 유니코드 같은 표준이 있다. 표준은 이렇게 독자적으로 만들어진 기술이 통일될 수 있게 하고 경쟁 구도를 만들어 주지만 표준의 수준이 낮은데 그 표준의 사용을 강요하면 발전에 방해가 된다. 하지만 단점에 비해 장점이 더 뚜렷하다. 오픈 소스는 GPL 저작권 라이선스가 적용되는데, 이 오픈 소스를 통해 개발된 모든 작업물은 마찬가지로 무료로 공유가 되어야 한다. 파이어폭스, 크롬, 아파치, 엔진엑스, 안드로이드 운영체제 모두 오픈 소스다.

##로그 31: 자유로운 소프트웨어, 오픈 소스

정리:
이해할 수 있는 형태로 작성된 코드를 소스 코드라고 한다. 이 소스 코드를 동작하는 형태로 컴파일한 것을 오브젝트 코드라고 한다. 오브젝트 코드는 읽어낼 수가 없다. 따라서 무단 복제 등 악용 방지를 위해 상용 소프트웨어 대부분은 이런 형태로 배포가 된다. 반대로 무료로 소스 코드를 공유하는 경우도 있다. 이를 오픈 소스라고 한다. 무료로 오픈을 하면 이득을 어떻게 챙기나 싶지만 다양한 서비스로 수익을 얻는다. 오픈 소스 소프트웨어는 다른 사람들이 버그를 발견해주는 등 여러 이득을 볼 수 있다.

##로그 32: 요약

정리:
프로그래밍 언어 하나로 모든 프로그래밍 과제를 할 수는 없다. 특정 과제에 특화된 언어가 있고, 또 더 적합한 언어가 나중에 개발될 거라는 믿음도 존재한다. 그리고 하드웨어 자원도 갈수록 발전되기 때문에 이에 맞춰 언어도 바뀔 수밖에 없다.

##로그 33: 컴퓨터를 작동하게 만드는 운영체제  
##로그 34: 가상 운영체제와 가상 머신  
##로그 35: 운영체제가 일하는 법  
##로그 36: 파일 시스템과 블록  
##로그 37: 파일을 휴지통에 넣을 때 일어나는 일  
##로그 38: 여러 작업을 수행하는 애플리케이션  
##로그 39: 소프트웨어의 계층 구조  
##로그 40: 요약  
##로그 41: 자바스크립트와 파이썬  
##로그 42: 프로그래밍 언어의 주요 개념  
##로그 43: 자바스크립트로 Hello, World 출력하기  
##로그 44: 사용자 이름 입력받아 출력하기  
##로그 45: 루프와 조건문  
##로그 46: 자바스크립트로 구글 지도에 위치 표시하기  
##로그 47: 자바스크립트는 어떻게 작동할까?  
##로그 48: 파이썬으로 Hello, World 출력하기  
##로그 49: 더하기 프로그램 만들기  
##로그 50: 파이썬으로 그래프 그리기  
##로그 51: 파이썬은 어떻게 작동할까?  
##로그 52: 요약
